%\documentclass{article} 
%\usepackage{amsmath}
%\usepackage[dvips]{graphicx}
%\author{Richard Ott} 
%\title{Using rottSigEx}

%\begin{document}

%\maketitle

%\begin{abstract}
%Instructions for the usage of the MCMC code developed for signal
%extraction for the NCD phase of SNO.  Also includes details of the structre
%and implementation of the code.
%\end{abstract}

\chapter{Code Usage for Malleus}
\label{CodeUsage}

\section{Introduction}
For the NCD phase of SNO, the first signal extraction used a Markov
Chain Monte Carlo (MCMC) method \cite{BlairNCD}, then new to the SNO
project.  For the Day/Night aspect of the NCD phase, we decided to use
this method again, as it has many benefits.  It properly integrates
``nuisance parameters'' (systematics), is able to handle a large
number of parameters and is ``embarrassingly parallel'', i.e. very
easy to run across multiple computers simultaneously.  With so many
parameters (more than 50 for the full data set with all systematics
and backgrounds), this is a crucial feature.  The code used for that
signal analysis, with the SNO-specific parts removed, became Malleus.
It was designed from the start to be flexible enough to be used for
other experiments with minimal change, ideally with only re-writing
configuration files.  How to write these configuration files and make
needed changes is described in this document.

At its core, Malleus runs the Metropolis algorithm, discussed in
\mbox{Chapters \ref{MCMC} and \ref{SigEx}}.  The likelihood function
evaluated is the Extended Likelihood, with the ``parent'' pdf that the
data is compared against generated by binning MC simulation events.
Some of the fit parameters are systematics, which are applied to the
MC events at the time of binning, so the resultant histogram is
rebuilt at each step in the Metropolis algorithm.  The output is the
posterior distribution for each of the parameters.  This can then be
fit if one chooses; a program to fit gaussians to the results is
supplied with the main program.

\section{What's in the box}
In its current incarnation, Malleus compiles five executables:
\begin{itemize}
\item {\tt Malleus} is the principal program.  This actually
  runs the MCMC
\item {\tt metaConfig.exe} is a conversion program to translate from
  the ``meta'' config file format (more human readable) to the config
  file format used by {\tt Malleus}.  Malleus can also directly read
  these meta files, but the other programs ({\tt autoFit.exe}, etc)
  cannot.
\item {\tt autoFit.exe} fits Gaussians (with some options) to the results
  of a run of {\tt Malleus}
\item {\tt getAutoCorr.exe} computes the autocorrelation of each parameter
  in the MCMC results, useful for finding optimal step sizes
\item {\tt drawResults.exe} creates a set of plots showing binned data
  v. binned MC for the parameters its given, useful for checking
  reasonableness of results
\end{itemize}

Of these, only {\tt Malleus} is actually \emph{necessary}.  We
highly recommend using {\tt metaConfig.exe} as well, as the ``native''
config file format used by {\tt Malleus} is very error-prone
when written by hand.  The other three are post-processing utilities,
included for convenience.

The code itself is C++ and compiles against CERN's Root, available at\\
{\tt http://root.cern.ch} \cite{RootBaseSite}.  If Root is installed
properly, simply running {\tt make} should be sufficient to build the
program.  Unfortunately, due to speed requirements it may be necessary
for the user to add systematic functions, which must be present at
compile time (i.e. the code itself must be edited).  This should be a
minimal change, and is detailed later.

\section{Malleus}
This section details the usage of the main program.  This description
assumes that you are writing meta files rather than directly writing
config files.  In addition, it assumes a basic working knowledge of
the Metropolis algorithm and the MC events $\rightarrow$ pdf process,
described in Chapters \ref{MCMC} and \ref{SigEx}.  Since the code is
still a work-in-progress, I'll strive to highlight potential pitfalls
and known places where the error handling may not catch problems.

\subsection{Objects}
This term has two meanings here: objects in the sense of
``Object-Oriented'' (i.e. C++ classes) and in the sense of things in
the program you can manipulate.  Here we discuss the latter.
The code has several ``layers'' of objects.  

At the top is the MCMC itself.  It keeps track of the MCMC status
(step, parameter values, likelihood value), the ``pure'' parameters
(numbers that are varied, but not associated with any other object;
they are independent objects in this description), and computes the
Likelihood functions not associated with another object (these are
called LogLikelihoodFormulas, and are also independent objects).  The
MCMC also handles I/O.  Options can be passed to the MCMC directly to
control its behavior, called directives.

The MCMC contains a number of Pdfs, each of which serves one function:
it takes a list of the current parameter values, and returns an
Extended Likelihood.  These are then summed and added to those
computed by the MCMC.  Each Pdf corresponds to and keeps track of a
data set $\{\vec{x}\}$; the dimension of events $\vec{x}_i$ determines
the dimension of the Pdf.  Currently, 1-D and 3-D Pdfs are available.
The binned pdf created from the MC data is also stored in Pdf and has
the same number of dimensions as the data.  Each dimension has an
Axis, which is an object in its own right.  In addition, the Pdf needs
to know what branches are present in the MC events.  If multiple MC
sets are used, they all need to have those branches.  This may require
the creation of dummy branches.

Each Pdf contains a number of Fluxes and Systematics, and a number of
Axes equal to Pdfs dimension.  Each Flux keeps track of a set of MC
events and its normalization.  Each Systematic is a function applied
to a subset of the Fluxes on an event-by-event basis.  These are the
``lowest level'', containing no further (user-accessible) parts.

\subsection{Parameters, Names and Keys}
At each step in the MCMC, each element of the set of parameters
$\vec{\alpha}$ is incremented.  This is still true for the code
implementation, though a step width of zero (no step) is allowed.
However, $\vec{\alpha}$ can be more complicated here - it is, in some
sense, just a collection of real numbers that are varied, that the
user can combine in almost any way he or she sees fit.

Parameters can be created explicitly as ``pure'' parameters (see
section \ref{sec:Parameter}), i.e. parameters not associated with
any object.  Additionally, whenever a Flux or Systematic is
created, a parameter with the same name is created automatically.  For
Fluxes these automatic parameters have a special meaning (see
sections \ref{sec:Flux} for details).  These
parameters can be combined using the AsymmFunc system described in
section \ref{sec:AsymmFunc}.  Since the program keeps track of
everything by its Name, each parameter must have a unique Name,
including those that are automatically generated.  So each Flux, Sys,
and Parameter must be uniquely named.

In the meta file, everything is described by key pairs (which become
unique when expanded to the Config file).  Except for {\tt new}, every
command in the meta file must be of the form {\tt Key=Value} or {\tt
  Key = Value} (these spaces are ignored), where {\tt Value} is either
an integer, a floating point number (read in as a {\tt Double\_t}) or
a string (which cannot have spaces in it); which one it is depends on
the {\tt Key} being used.  See section \ref{sec:BasicMeta} examples of
use, and the appropriate section below for valid Keys for a particular
object.

\subsection{Program behavior}
\label{sec:ProgramBehavior}
The program begins by reading in the config file and using that
information to create and set up all the appropriate objects, and set
up the output file and TTree.  It then initializes all parameters and
computes the Log Likelhood (LL) for these initial parameter values, to
create the ``step zero'' starting point for the MCMC.

The code then runs the Metropolis algorithm.  At a given step, the code:
\begin{enumerate}
\item Creates a proposed value for each parameter by adding to it a draw
  from a Gaussian of mean zero and width specified by the user
  (constant throughout the program), giving $\tilde{\vec{\alpha}}$
\item Computes any parameters whose values are altered by an AsymmFunc
\item Computes the LL contribution from any LogLikelihoodFormulas and
  checks to see if any pure Parameters are outside their minimum or
  maximum (if specified), and computes their constraints' contributions
  to the LL
\item Gives a Pdf the current list of parameter values and asks it for
  its contribution to the LL.  It does this for each Pdf in order of
  appearance in the meta file (this order shouldn't matter).  Each
  Pdf:
  \begin{enumerate}
  \item Checks to see if any parameters it ``owns'' are out of their bounds
  \item Rebuilds the MC pdf by:
    \begin{enumerate}
    \item Emptying the histogram
    \item Taking an MC event from a Flux
    \item Passing this MC event through each Sys that affects it, in
      the order they appear in the meta file (order may matter here),
      giving the new value for the event
    \item Filling this event into the histogram (only using those
      values which correspond to Pdf dimensions), with a weight of\\
      {\tt InternalUseWeight*FluxName/TimesExpected} (see \ref{sec:Flux})
    \item Repeating this for each event in the Flux
    \item Repeating this for each Flux (in the order of appearance,
      though order shouldn't matter)
    \item Checking that no bins are zero or negative, and setting any
      that are to a nominal value (currently 1e-10), to avoid problems
      with taking the logarithm
    \item Dividing each histogram bin by that bin's volume (width,
    area, etc) to ``normalize'' it to a proper un-normalized pdf
    \end{enumerate}
  \item Takes each data point $\vec{x}_i$, asks the MC pdf for
    its value at that point to get $\displaystyle
    p(\vec{x}_i|\tilde{\vec{\alpha}})$ and computes the LL
  \item Computes the LL contributions from constraints on any
    parameters it ``owns''
  \item Returns this LL
  \end{enumerate}
\item Compares the computed LL with the LL from previous step to
  decide whether to accept the step (see \mbox{Chapter \ref{MCMC}})
\item If step is accepted, updates parameter list, if not, discards
  proposed parameters
\item Records current parameter list in TTree
\item Every 100th step, AutoSaves TTree
\item After all steps are taken, saves TTree to output file and exits
\end{enumerate}

\subsection{Basic meta file}
\label{sec:BasicMeta}
The only control we have over the process in section
\ref{sec:ProgramBehavior} is in setting up the system.  Via the
mechanism of the config file, we can create parameters, set step
sizes, control the behavior of the MCMC to a certain degree, set up
AsymmFuncs and LogLikelihoodFormulas, command the creation of any
combination of objects, etc.  But then the code runs its prescribed
process.  The config files themselves must have unique keys for each
command, accomplished via a numbering system.  This turned out to be
difficult to keep track of, since mis-numbering caused odd behavior,
so I created the much more readable meta files.  Running {\tt
  metaConfig.exe} converts from meta file to config file.  Malleus can
read these meta files directly (with the -m switch) or the config file
(with the -c switch), but the other programs can only read the config
files.

Every meta file consists of some number of directives to the MCMC, to
control how many steps to take, where to save files, etc; the creation
of at least one Pdf, and at least one Flux inside that Pdf, plus a
number of Axis objects equal to the dimension of the Pdf.  Most also
have some Systematics as well, and a few pure Parameters.  An example
of a simple metafile is:

\begin{verbatim}
MCMC_ChainLength=5000
MCMC_PrintFrequency=100
OutputFilename=results_test.root

new Pdf
Name=SimpleTest
Dimension=1
MCBranch=Energy
DataFile=fakeData.root
DataTree=data

new Axis
Name=Energy
Bin=0
Bin=0.1
Bin=0.3
Bin=0.7
Bin=1

new Sys
Name=AddConstant
Init=0.1
Width=0.01
Mean=0.1
Sigma=0.05
Function=AddConst
Target=Energy
MCMCParameterValue=AddConstant

new Flux
Name=Sim
File=fakeMC.root
Tree=mc
TimesExpected=5
Min=0
Init=1
Width=0.01
\end{verbatim}

In general, a new object is created with the \verb|new| command.  {\tt
metaConfig.exe} knows about the heirarchy of objects, so any Axis,
Flux, etc. created will go in the Pdf most recently created.  Between
one invocation of \verb|new| and the next, commands apply to the
``active'' object.  So \verb|Name=AddConstant| above gives the Systematic
the name ``AddConstant''.  Note that commands to the MCMC directly and
the creation of pure Parameters can occur anywhere and ignore
heirarchy rules.

Working through the sample file one line at a time (skipping
repeats):\medskip\\ 
\verb|MCMC_ChainLength=5000| tells the MCMC to take 5000
total steps\medskip\\ 
\verb|MCMC_PrintFrequency=100| tells the MCMC to print
its status to stdout at every 100th step, useful if something goes
wrong\medskip\\ 
\verb|OutputFilename=results_test.root| sets the output file.
This defaults to the current directory.  This file will
contain a single TTree named Tmcmc, this can be overridden (see
\ref{sec:MCMCDirectives})\medskip\\ 
\verb|new Pdf| creates a new Pdf, at this stage with undefined
characteristics\medskip\\
\verb|Name=SimpleTest| gives the Pdf the name ``SimpleTest''\medskip\\
\verb|Dimension=1| sets SimpleTest to be a 1-D Pdf\medskip\\
\verb|MCBranch=Energy| tells SimpleTest that its Fluxes will contain
the branch Energy.  If we wanted more branches (for example, if there
was a branch ``TrueEnergy'' that was the input simulation energy,
useful for altering resolutions), we just add an additional line
\verb|MCBranch=TrueEnergy|\medskip\\
\verb|DataFile=fakeData.root| tells SimpleTest that its data is
located in the file fakeData.root\medskip\\
\verb|DataTree=data| tells SimpleTest to look for a TTree named data
for its data\medskip\\
\verb|Bin=0| Tells the Energy Axis the location of bin boundaries.  In
this case, it has 4 bins, $[0,0.1)$, $[0.1,0.3)$, $[0.3,0.7)$ and
$[0.7,1]$\medskip\\
\verb|Init=0.1| tells the MCMC that the parameter AddConstant takes the
value 0.1 initially, before stepping starts\medskip\\
\verb|Width=0.01| tells the MCMC that the parameter AddConstant should be
incremented by a Gaussian draw with $\sigma=0.01$ at each step\medskip\\
\verb|Mean=0.1| and \verb|Sigma=0.05| tell the pdf SimpleTest that the
parameter AddConstant has a Gaussian constraint of mean 0.1 and
$\sigma=0.05$, which is added as a penalty term to the Likelihood
computed by SimpleTest\medskip\\
\verb|Function=AddConst| tells the AddConstant Sys to use the function
AddConst (defined in \verb|FunctionDefs.h|).  See \mbox{Section
  \ref{sec:Sys}}
for details.\medskip\\
\verb|Target=Energy| sets the AddConstant Sys to alter the branch
Energy\medskip\\
\verb|MCMCParameterValue=AddConstant| sets the first (and in this case
only) parameter of the AddConst function to be the automatically
created variable AddConstant\medskip\\
\verb|File=fakeMC.root| tells the Flux Sim that the MC events for it
are in the file fakeMC.root\medskip\\
\verb|Tree=mc| tells Sim to look for a TTree named mc for its events\medskip\\
\verb|TimesExpected=5| tells Sim that it has 5 times as many MC events
as it expects for data events, i.e. its simulation had ``five
experiments'' worth of simulated events.  This acts as a
normalization, more on that in \mbox{Section \ref{sec:Flux}}\medskip\\
\verb|Min=0| tells the MCMC that the parameter Sim has minimum 0.  If
it is ever below this value, it returns Likelihood zero (i.e. it
cannot take this step).  Since we're using Log Likelihoods, it
actually returns a very large negative value (but not negative infinity)

\subsection{new}
As mentioned, the \verb|new| command creates a new object.  Valid
objects to create are: {\tt Pdf}, {\tt Sys}, {\tt Flux},
{\tt Axis}, {\tt Parameter} and {\tt LogLikelihoodFormula}.  They must
obey the heirarchy: to create a Flux, Sys, or Axis, a Pdf must
already exist for it to ``live in''.  At any given time, only the most
recently created object is ``active'' and any commands given apply to
it.  MCMC Directives ignore this rule and can be anywhere in the file,
but I've found it easiest to just include all of them at the beginning
of the file to prevent confusion later.

\subsection{MCMC Directives}
\label{sec:MCMCDirectives}
A number of commands can be given to the MCMC to change its behavior.
A few of these are necessary and showed up in the sample file.  If a
command isn't present, a default value is assumed, listed with that
command below.  A full listing of these commands and their
consequences is:\medskip\\
\verb|MCMC_ChainLength=integer| sets the total length of the chain.
DynamicSteps are taken first, then normal steps.  If this number is
less than \verb|MCMC_DynamicSteps|, it is ignored.  If it isn't
present, the MCMC defaults to 1000 steps.\medskip\\
\verb|MCMC_DynamicSteps=integer| tells the MCMC to take steps where
the step size is allowed to vary, with the goal that the chain take
23.5\% steps.  This was implemented for testing and is described
in \mbox{Section \ref{rott:StepSizeFinding}}.  Default is 0.\medskip\\
\verb|MCMC_PrintFrequency=integer| controls how often the MCMC prints
its status to the screen, setting it to print every $n^{\mathrm{th}}$
step.  Useful for making sure the chain is still going and checking on
its status as it is running.  Default is 1
(i.e.  every step).\medskip\\
\verb|MCMC_SkipSteps=integer| originally was going to control how many
``burn-in'' period steps to skip when making graphs, but all of the
graphing programs take that input separately and ignore this now.
Defaults to 0.\medskip\\
\verb|MCMC_UseAsymmetry=true/false| tells the MCMC whether to check
for AsymmFuncs.  It \emph{must} be set to \verb|true| if AsymmFuncs
are being used.  See section \ref{sec:AsymmFunc} for more details.
Default is \verb|false|.\medskip\\
\verb|MCMC_SaveProposed=true/false| tells the MCMC whether to save the
proposed values for each step as well as the accepted.  These are the
values $\tilde{\vec{\alpha}}$ generated by varying the parameters.  If
the step is rejected, these values are lost if this set to
\verb|false|, but the output files are half the size.  Useful for
debugging.  Default is \verb|true|.  These values are saved as
\verb|ProName|, where Name is the parameter name, while the accepted
values are \verb|AccName|.\medskip\\
\verb|MCMC_SaveUnvaried=true/false| tells the MCMC whether to save the
value of parameters with width $\leq 0$, i.e. those that aren't varied
by the MCMC.  Often useful for debugging.  Setting this to
\verb|false| gives smaller output files.  Default is \verb|true|.\medskip\\
\verb|RandomSeed=integer| sets the seed for the TRandom3 that
generates the random numbers needed throughout the MCMC process.
Default is 0, i.e. a random seed based on the clock time, among other
things.\medskip\\
\verb|OutputDirectory=string| sets the directory to which MCMC writes
output files.  Default is \verb|.| (current directory).\medskip\\
\verb|OutputFilename=string| sets the output filename.  It is
concatenated with the OutputDirectory internally, so putting the
directory string as part of the file name has the same result as
setting
\verb|OutputDirectory|.  Default is \verb|results.root|.\medskip\\
\verb|OutputTreeName=string| sets the name of the TTree created in the
output file.  Default is \verb|Tmcmc|.  Note that \verb|autoFit.exe|
assumes that the tree is named \verb|Tmcmc|.

\subsection{Parameter}
\label{sec:Parameter}
A ``pure'' parameter is one not associated with another object.  It is
simply a number that is varied when the parameters are varied by the
MCMC.  It can be altered with an AsymmFunc.  To create one, use {\tt
new Parameter}.  Required settings are {\tt Name}, {\tt Init} and {\tt
Width}.  {\tt Name} must be unique.  If {\tt Width} is $\leq 0$, this
Parameter will not be varied (though AsymmFunc can still change its
value).  Valid Keys are:\medskip\\ 
\verb|Name=string| sets the name.  Must be unique.  If this isn't
present, an error message is generated and setup fails. \medskip\\
\verb|Init=double| sets the initial value.  Error and setup failure if
not present.\medskip\\
\verb|Width=double| sets $\sigma$ for the Gaussian drawn from at the
incrementing step for this variable.  If \verb|Width| is $\leq 0$,
parameter is not incremented.  Error and setup failure if not
present.\medskip\\
\verb|Mean=double| creates a Gaussian constraint for this parameter.
Sets $\mu$ of this constraint to \verb|Mean|.  If this is present and
\verb|Sigma| is not, an error is generated and setup fails.  If
neither is present, no constraint.  See \verb|Sigma| for more
details.\medskip\\
\verb|Sigma=double| creates a Gaussian constraint
for this parameter.  Sets $\sigma$ of this constraint to \verb|Sigma|.
This constraint gives LL contribution $\displaystyle
-\frac{(\alpha-\mu)^2}{2 \sigma^2}$.  If this is present and
\verb|Mean| is not, an error is generated and setup fails.  If neither
is present, no constraint.\medskip\\
\verb|Min=double| sets the minimum value for the parameter.  If its
value goes below \verb|Min|, the returned LL is $-1e200$, effectively
$-\inf$, so no step is taken.  If this is not present, no
minimum.\medskip\\
\verb|Max=double| sets the maximum value for the parameter.  If its
value goes above \verb|Max|, the returned LL is $-1e200$, effectively
$-\inf$, so no step is taken.  If this is not present, no
maximum.\medskip\\
\verb|AsymmFunc=string| creates an Asymm function for this parameter.
See section \ref{sec:AsymmFunc}.  If this is not present, no
AsymmFunc.\medskip\\
\verb|AsymmPar=string| sets a parameter for the Asymm Func.  See
section \ref{sec:AsymmFunc}.  If this is present and \verb|AsymmFunc|
isn't, an error is returned and setup fails.

\subsection{Pdf}
\label{sec:Pdf}
A Pdf is a basic building block of the system.  It contains a data set
and the corresponding histogram for the binned probability
distribution for that data.  Its dimension must be specified and a
number of Axis objects equal to that dimension must be created.  The
data must be stored in a TTree in a \verb|.root| file, and only the
branches that have the same name as an Axis will be used.  All events
in the data set \emph{must} be in the range of the bins defined in the
Axis.  If this isn't the case, the behavior is undefined (and is
likely to be a program crash, or at least very strange behavior),
since this will involve requesting binned pdf values outside the range
where they are defined.  Any number of \verb|MCBranches| can be
defined, these describe the branches that the MC events in the various
Fluxes will have.  This will cause all Fluxes to have the same
branches, and only those branches will be used.  Each Axis name must
have a corresponding MCBranch and each set of MC events must have
branches with the same names as the Axis objects.  Valid Keys
are:\medskip\\
\verb|Name=string| sets the name.  Must be unique.  If this isn't
present, an error message is generated and setup fails. \medskip\\
\verb|Dimension=integer| sets the dimension of the Pdf.  A number of
Axis variables equal to this \verb|Dimension| must be created in the
Pdf.  Only dimensions 1 and 3 are currently available.  If this isn't
present, an error message is generated and setup fails.\medskip\\
\verb|DataFile=string| sets the location of the file containing the
data events.  Can include a directory string, assumes current working
directory otherwise.  The file must contain the TTree named in
\verb|DataTree|.  If this isn't present, an error message is generated
and setup fails.\medskip\\
\verb|DataTree=string| sets the name of the TTree containing the data
events, in the file \verb|DataFile|.  Must contain branches with the
same names as the Axis objects.  If this isn't present, an error
message is generated and setup fails.\medskip\\
\verb|MCBranch=string| tells the Pdf to look for a branch of this name
in the TTrees containing the MC events in the Flux objects.  To have
the Pdf look for more than one branch (necessary for 3D Pdfs, useful
for any Pdf), simply call this for each branch.  They will be numbered
(in the order called) internally.  Must be called at least a number of
times equal to the \verb|Dimension| of the Pdf.

\subsection{Flux}
\label{sec:Flux}
A Flux object must live in a Pdf object, so a Pdf must be created
(with \verb|new|) before a Flux is created.  Each Flux contains one
set of MC events.  When this is created, a parameter with the same
\verb|Name| as the Flux is created.  During the filling of the MC
binned pdf, the Flux hands events to the Pdf, and they are filled in
to the Pdf with weight
\verb|Name|*\verb|InternalUseWeight|/\verb|TimesExpected|.
\verb|InternalUseWeight| is an internally created MC branch that is
used for reweighting procedures, see section \ref{sec:Sys} for more
details.  The \verb|TimesExpected| nominally is used to keep track of
how many ``experiments worth'' of MC you have, i.e. if the MC contains
500 times the events you expect for that particular signal in your
data, a \verb|TimesExpected| of 500 gives a nominal value of 1 to the
automatic parameter.  Another option is \verb|TimesExpected| set to
the number of events in your analysis window, then the nominal value
of the automatic variable is the number of data events.  These MC
events are not restricted to being in the range specified by the Axis
objects; events outside the range are ignored.  This is imporant for
any Systematic that changes the effective analysis window (say by
adding a constant to the energy or position) - if this happens, there
need to be MC events in the new region or the log likelihood will not
give the correct value.  Fluxes can also have a \verb|FluxNumber|
assigned, which is a distinguishing feature used by the Sys to decide
which Flux to act on (so if you have a systematic that you want to act
on this Flux and not others, give it a distinct \verb|FluxNumber|).
Any number of Pdfs can share the same \verb|FluxNumber|.  Valid Keys
are:\medskip\\ 
\verb|Name=string| sets the name.  Must be unique.  If
this isn't present, an error message is generated and setup
fails. \medskip\\ 
\verb|Init=double| sets the initial value of the
automatic parameter.  Error and setup failure if not
present.\medskip\\ 
\verb|Width=double| sets $\sigma$ for the Gaussian
drawn from at the incrementing step for the automatic parameter.  If
\verb|Width| is $\leq 0$, parameter is not incremented.  Error and
setup failure if not present.\medskip\\ 
\verb|Mean=double| creates a
Gaussian constraint for the automatic parameter.  Sets $\mu$ of this
constraint to \verb|Mean|.  If this is present and \verb|Sigma| is
not, an error is generated and setup fails.  If neither is present, no
constraint.  See \verb|Sigma| for more details.\medskip\\
\verb|Sigma=double| creates a Gaussian constraint for the automatic
parameter.  Sets $\sigma$ of this constraint to \verb|Sigma|.  This
constraint gives LL contribution $\displaystyle
-\frac{(\alpha-\mu)^2}{2 \sigma^2}$.  If this is present and
\verb|Mean| is not, an error is generated and setup fails.  If neither
is present, no constraint.\medskip\\ 
\verb|Min=double| sets the
minimum value for the automatic parameter.  If its value goes below
\verb|Min|, the returned LL is $-1e200$, effectively $-\inf$, so no
step is taken.  If this is not present, no minimum.\medskip\\
\verb|Max=double| sets the maximum value for the automatic parameter.
If its value goes above \verb|Max|, the returned LL is $-1e200$,
effectively $-\inf$, so no step is taken.  If this is not present, no
maximum.\medskip\\ 
\verb|AsymmFunc=string| creates an Asymm function
for the automatic parameter.  See section \ref{sec:AsymmFunc}.  If
this is not present, no AsymmFunc.\medskip\\ 
\verb|AsymmPar=string|
sets a parameter for the Asymm Func.  See section \ref{sec:AsymmFunc}.
If this is present and \verb|AsymmFunc| isn't, an error is returned
and setup fails.  \verb|File| sets the location of the file containing
the MC events.  Can include a directory string, assumes current
working directory otherwise.  The file must contain the TTree named in
\verb|Tree|.  If this isn't present, an error message is generated and
setup fails.\medskip\\ 
\verb|Tree=string| sets the name of the TTree
containing the MC events, in the file \verb|File|.  Must contain
branches with the same names as the MCBranches of the Pdf this Flux is
in.  If this isn't present, an error message is generated and setup
fails.\medskip\\ 
\verb|TimesExpected=double| weights each MC event
when the binned pdf is filled with\\
(automatic variable)*\verb|InternalUseWeight|/\verb|TimesExpected|.
If this isn't present, an error message is generated and setup
fails.\medskip\\ 
\verb|FluxNumber=integer| sets the \verb|FluxNumber|
of the Flux.  This allows for Sys to be selective in which Fluxes they
act on, as one of the settings for Sys is which FluxNumbers to affect.
Fluxes can share the same Flux number.  Default is -1.

\subsection{Sys}
\label{sec:Sys}
The Sys are functions that are applied to the MC events before they
are filled in to the binned pdf.  They can be selectively applied to
some Fluxes and not others, and only apply to Fluxes in the Pdf in
which the Sys object resides.  A Sys can use any number of MC branches
and parameters in its evaluation, but can only alter (target) one MC
branch.  So each Sys is a function taking some number of real values
and returning a single real value.  In addition to the MC Branches
listed in Pdf, there is an additional, internal branch created named
\verb|InternalUseWeight|.  It is set to 1, but can be targeted with
the Sys to change this value.  \verb|InternalUseWeight| is directly
multiplied by any other weighting for the MC events, so that it
effectively acts a relative weight for MC events.  Since multiple Sys
may (and usually do) apply to the same Flux (and hence to the same MC
event), the Sys function returns not the new value of the branch, but
the change in that value due to this Sys's action, so that each Sys
can see the values as they originally appear in the Flux.  The option
to look at the branch values including all changes up to that point
(the Sys are applied in the order they appear in the meta file) is
also available, but then the order the Sys are applied in matters.  To
make a Sys apply to only a select subset of the Fluxes, it can be set
to only act on certain FluxNumbers.  When a Sys is created, a
parameter of the same name is automatically created.  This parameter
does not have to be used in the Sys, but must be unique as it
identifies the Sys to the code.

% Unfortunately, much of the Sys behavior must still be hard-coded in to
% the system.  This is due to a combination of speed requirements (the
% Sys are evaluated for \emph{every MC event}, so they are called
% \emph{a lot}) and a code upgrade that never got implemented.  In fact,
% the meta file can only control the behavior of the automatic parameter
% generated when Sys is created.  All other control is done by directly
% altering the source files \verb|Sys.cxx| and \verb|FunctionDefs.h|.
% This must be done with care, as error checking inside the code is not
% very thorough.

% First, \verb|Sys.cxx|.  In this file, there is a member function
% \verb|Sys::LookupName|.  In this function is a very long chain of
% else-if statements.  This is what needs to be edited.  An example is:
% \begin{verbatim}
% } else if (nameToGet == "ZRemap_Day"){
%   sysFunc = new ZRemap();
%   found &= LookupNameChecker("ZShift",mcmcParNames,'p')
%   found &= LookupNameChecker("ZScale_Day",mcmcParNames,'p');
%   found &= LookupNameChecker("ZResConst",mcmcParNames,'p');
%   found &= LookupNameChecker("ZResLin",mcmcParNames,'p');
%   found &= LookupNameChecker("z",branchNames,'d');
%   found &= LookupNameChecker("truez",branchNames,'d');
%   dataTarget = SearchStringVector(branchNames,"z");
%   AddFluxAffected(0);
%   AddFluxAffected(1);
%   AddFluxAffected(-1);
%   useMultiply=false;
%   useOriginalData = true;
% }
% \end{verbatim}
% Each one begins with \verb|if (nameToGet == "string")|.  The
% ``string'' here (\verb|ZRemap_Day| in the example) is the name of a
% Sys.  This is read in from the config file and matched, so only the
% Sys with this name follows the behavior set here, meaning that
% \emph{each} Sys must have a corresponding entry in this else-if table.
% Part of The Upgrade That Never Was was to make this more
% flexible.  The next line is \verb|sysFunc = new FunctionName()|, where
% the FunctionName is the name of a class defined in
% \verb|FunctionDefs.h|, see the next paragraph for details.  The next
% set of lines,\\
% \verb|found &= LookupNameChecker("ParName",parNamesList,'type')|, sets
% the values that go in to the Sys function.  Each invocation adds a
% parameter or MC branch (with name ``ParName''), in the order they are
% called.  The next entry, \verb|mcmcParNames| or \verb|branchNames|,
% selects parameters from the parameter list $\{\vec{\alpha}\}$ or from
% the list of MC branches, respectively.  The \verb|branchNames| list
% includes the automatically generated \verb|InternalUseWeight|, used
% for re-weighting.  The final argument, \verb|'type'|, must be
% \verb|'p'| for mcmcParNames and \verb|'d'| for branchNames.  This
% doesn't affect the actual functioning of the Sys; it is used to help
% make the resultant error messages more clear.  It is critically
% important that all the mcmcPars are listed before the MC branches,
% otherwise the Sys will behave in an ill-determined way.  The next
% line, \verb|dataTarget = SearchStringVector(branchNames,"name")|,
% selects which MC branch the Sys will alter.  Only one selection can be
% made.  Also, there is absolutely no error checking on this, so the
% name \emph{must} be spelled correctly, otherwise there is likely to be
% a seg fault.  Any branch, plus \verb|InternalUseWeight|, can be
% targeted.  The \verb|AddFluxAffected| function tells the Sys which
% FluxNumbers it should affect.  Each call adds a FluxNumber to affect
% to the Sys's list.  If this isn't called at all, it defaults to
% affecting all FluxNumbers.  Note that a flux with no FluxNumber
% specified has FluxNumber $-1$.  The line \verb|useMultiply| tells the
% Sys to add its value to the target branch (if \verb|false|) or
% multiply the target branch by the Sys's value (if \verb|true|).  The
% latter is necessary when re-weighting, as the default weight is $1$.
% The line \verb|useOriginalData| tells the Sys to use the values the MC
% event's branches had before any other Sys has been applied (if
% \verb|true|), or after all Sys \emph{up to that point} have been
% applied (if \verb|false|).  This latter point is important: the order
% matters.  Sys are called in the order they are listed in the meta
% file.

The possible functional forms that can be used by Sys (in the meta
file they are selected by using \verb|Function=name|) are defined in
\verb|FunctionDefs.h|.  A simple selection is included, but will most
likely need to be expanded upon to specialize to a specific task.
This is done by creating a class that inherits from the class
\verb|RealFunction| (defined in \verb|RealFunction.h| and
\verb|RealFunction.cxx|).  This function needs to know how many
parameters it is looking for, which must match the number listed in
the configuration file.  Note that a function defined here is not
restricted to a single Sys entry; if there are multiple Sys that use
the same function form, it is best to use a single function for them.
An example definition is:
\begin{verbatim}
class MultiplyConst : public RealFunction {
 public:
  MultiplyConst() {
    nPars = 2;
    parameters = new Double_t[nPars];
  }

  Double_t Eval() {
    return (parameters[0]*parameters[1]);
  }
};
\end{verbatim}
Only two things need to be defined: the constructor and the function
\verb|Eval|.  The \verb|nPars| term defines how many parameters the
function takes.  The function \verb|Eval| actually defines the
systematic function.  This can call any function in \verb|TMath| (from
Root) and can use \verb|TRandom3| (from Root), though random number
draws are very slow and should be used only if necessary.  Note that
the way that Sys works needs this function to return the \emph{change}
in the target value, if \verb|useMultiply=false|.  In the above case,
if this is the only Sys, the resulting value will be $x_{new} = x_{MC}
+ a_0 x_{MC}$ (where $a_0$ is parameters[0]).  The \verb|parameters|
array has the values of the MCMCParameterValues and the MCBranchValues
from the config file.  The order is the order selected in the config
file, with MCMCParameterValues first and MCBranchValues second (the
order is hard-coded).  A mis-match between \verb|nPars| and the number
of parameters in the parameters array will result in undefined
behavior, and could cause a seg fault, as with any array.

Since the Sys are somewhat complicated and at the heart of the pdf
generation process, we will present two stereotypical Sys.  The first
will implement $x_{new} = x_{MC} + a_0 x_{MC}$, i.e. $\Delta x = a_0
x_{MC}$, while the second will multiply the event's weight by a
constant.  For both, we will assume we have a 1-D Pdf with an Axis
named ``x'', and our MC events contain just one branch (also named
``x'').  In addition, we will assume we created a parameter with the
following meta file command (where the Init and Width aren't relevant
to our discussion, but are included for completeness)
\begin{verbatim}
new Parameter
Name=Const
Init=1
Width=0.1
\end{verbatim}

To implement $\Delta x = a_0 x_{MC}$, where $a_0$ is the Const
parameter, the meta file reads
\begin{verbatim}
new Sys
Name=LinearScale
Init=0
Width=-1
Function=MultiplyConst
Target=x
MCMCParameterValue=Const
MCBranchValue=x
UseMultiply=false
UseOriginalData=true
\end{verbatim}
Note that the \verb|UseMultiply| and \verb|UseOriginalData| commands
are unnecessary, since they are using the default values.  Also, we do
not use the automatically generated LinearScale variable, so we do not
bother to vary or constrain it.

To multiply the weight by a constant, the meta file reads
\begin{verbatim}
new Sys
Name=WeightAdjust
Init=0
Width=-1
Function=AddConst
Target=InternalUseWeight
MCMCParameterValue=Const
UseMultiply=true
UseOriginalData=false
\end{verbatim}
Here again the automatically generated variable is not used.  Note
that the AddConst function just returns the value of the parameter,
which is what we need.  Also, note that the \verb|UseMultiply| and
\verb|UseOriginalData| variables are needed, as we are multiplying the
InternalUseWeight by a constant.  If this were the only such
multiplier, the UseOriginalData would be optional, but if multiple
ones are present, for the multiplication to work correctly we need it
to be \verb|false|.

In the meta file, the Sys's function, target branch to alter, and
parameters can be set.  In addition, the behavior of the automatic
parameter sharing the name of the Sys can be controlled, with the same
controls as the
Parameters of section \ref{sec:Parameter}.  Valid Keys are:\medskip\\
\verb|Name=string| sets the name.  Must be unique.  If this isn't
present, an error message is generated and setup fails. \medskip\\
\verb|Init=double| sets the initial value.  Error and setup failure if
not present.\medskip\\
\verb|Width=double| sets $\sigma$ for the Gaussian drawn from at the
incrementing step for this variable.  If \verb|Width| is $\leq 0$,
parameter is not incremented.  Error and setup failure if not
present.\medskip\\
\verb|Mean=double| creates a Gaussian constraint for this parameter.
Sets $\mu$ of this constraint to \verb|Mean|.  If this is present and
\verb|Sigma| is not, an error is generated and setup fails.  If
neither is present, no constraint.  See \verb|Sigma| for more
details.\medskip\\
\verb|Sigma=double| creates a Gaussian constraint for this parameter.
Sets $\sigma$ of this constraint to \verb|Sigma|.  This constraint
gives LL contribution $\displaystyle -\frac{(\alpha-\mu)^2}{2
  \sigma^2}$.  If this is present and \verb|Mean| is not, an error is
generated and setup fails.  If neither
is present, no constraint.\medskip\\
\verb|Min=double| sets the minimum value for the parameter.  If its
value goes below \verb|Min|, the returned LL is $-1e200$, effectively
$-\inf$, so no step is taken.  If this is not present, no
minimum.\medskip\\
\verb|Max=double| sets the maximum value for the parameter.  If its
value goes above \verb|Max|, the returned LL is $-1e200$, effectively
$-\inf$, so no step is taken.  If this is not present, no
maximum.\medskip\\
\verb|AsymmFunc=string| creates an Asymm function for this parameter.
See section \ref{sec:AsymmFunc}.  If this is not present, no
AsymmFunc.\medskip\\
\verb|AsymmPar=string| sets a parameter for the Asymm Func.  See
section \ref{sec:AsymmFunc}.  If this is present and \verb|AsymmFunc|
isn't, an error is returned and setup fails.\medskip\\
\verb|Function=string| selects the function from \verb|FunctionDefs.h|
to use.\medskip\\
\verb|Target=string| selects which MC branch is altered by this Sys.
Note that if \verb|UseMultiply=False|, the value of this Sys is
\emph{added} to the branch, rather than replacing it.  If
\verb|UseMultiply=true|, the branch value is multiplied by the Sys
value.  Having some Sys multiply a branch and others add to the same
branch results in undefined behavior.\medskip\\
\verb|UseMultiply=true/false| sets the Sys to either add its value to
the targeted MC branch (\verb|false|) or multiply the targeted branch
by the Sys value (\verb|true|).\medskip\\
\verb|UseOriginalData=true/false| sets the Sys to either take the MC
branch values (if applicable) as they appear in the Flux (i.e. the
unaltered MC values), if \verb|true|, or after applying all Sys
applied thus far, if \verb|false|\medskip\\
\verb|AddFluxAffected=integer| tells the Sys to apply to Fluxes
labeled with the flux number selected.  Can be called multiple times
to affect multiple FluxNumbers.  If not called, default behavior is to
affect all Fluxes.\medskip\\
\verb|MCMCParameterValue=string| sets a parameter of the Sys's
function to the selected MCMC parameter (either pure Parameter or
automatically generated parameter).  Calling multiple times sets
multiple parameters, in order - if a function needs four parameters,
four calls will identify all four parameters.  Note that if both
MCMCParameterValue and MCBranchValue are used (which is normally the
case), the MCMCParameterValue terms are first, regardless of order in
the config file.\medskip\\
\verb|MCBranchValue=string| sets a parameter of the Sys's function to
the selected MC branch.  Calling multiple times sets multiple
parameters, in order - if a function needs four parameters, four calls
will identify all four parameters.  Note that if both
MCMCParameterValue and MCBranchValue are used (which is normally the
case), the MCMCParameterValue terms are first, regardless of order in
the config file.\medskip\\


\subsection{AsymmFunc}
\label{sec:AsymmFunc}
The AsymmFunc system is used to alter the values of parameters in
user-specified ways, rather than just the random draw used to vary
them.  The basic idea is that \verb|AsymmFunc| defines a function,
using the notation of Root's \verb|TF1|, which is \emph{added} to the
parameter's value.  The reason for adding rather than replacing is an
artifact of how this is implemented: it uses the machinery of Sys.
The \verb|AsymmPar| then specify what parameters to use in the
function.  An example use is:
\begin{verbatim}
new Parameter
Name=NCFlux
Init=0
Width=-1
AsymmFunc=[0]*[1]-[2]
AsymmPar=BoronFlux
AsymmPar=PMTEfficiency
AsymmPar=NCFlux
\end{verbatim}
This takes the Parameter NCFlux and sets its value to
be\medskip\\ 
\mbox{NCFlux + BoronFlux*PMTEfficiency - NCFlux =
  BoronFlux*PMTEfficiency}\medskip\\
In this case, the NCFlux parameter isn't varied because its value is
irrelevant - it is entirely replaced by the combination.  This doesn't
have to be the case, of course.  The notation of \verb|AsymmFunc| is
that each number in a set of square brackets is a parameter (of
\verb|TF1|); there cannot be spaces in the function definition (due to
parsing issues).  Any parameter defined in the meta file is valid to
use, and the function itself can use any combination of basic arithmetic 
operations and functions defined in TMath.  Random numbers are not
available here, which should not be a strong constraint as the
parameters are randomly varied.  The \verb|AsymmPar| correspond to the
parameters \verb|[i]|, numbered in order of appearance starting with
$0$.  There is limited error checking on the parameter numbers: the
system should give an error if too high of a parameter number is
requested in the \verb|AsymmFunc|, but will not if a number is
missing.  This can be problematic for long functions, especially when
they are changed; exercise caution.

\section{metaConfig.exe}
\label{sec:metaConfig}
This section can be safely skipped by most users.  It details what
happens during the conversion process from the human-readable meta
file to the less-readable (but still human readable, just much harder
to follow) config file.

The config file format used by \verb|Malleus| is parsed and read-in by
the class described by \verb|ConfigFile.h|.  This is the only code
reused from \cite{BlairNCD}, as it is an open source utility available
at \cite{ConfigFileSite}.  The basic premise is that the config file
consists of Key-Value pairs, similar to the meta file.  The major
differences are that each Key must be unique, the order that the keys
appear in does not matter at all, and the existence of objects is kept
track of by a numbering system.

The {\tt metaConfig.exe} system is fairly simple: it keeps a running
total of each kind of object present.  When the first {\tt Pdf} is
created with {\tt new}, the {\tt Pdf} counter is set to $0$.  Until
{\tt new} is called again, the system then adds {\tt Pdf\_0\_} to the
beginning of each command, so that\\
{\tt Name = FirstPdf}\\
is converted into\\
{\tt Pdf\_0\_Name=FirstPdf}\\
A special case here is {\tt MCBranch} (or anything else that can be
called repeatedly: {\tt AsymmPar}, {\tt MCMCParameterValue},
$\ldots$), which has its own numbering system, so that every time it
is called it is incremented.  As an
example\\
{\tt MCBranch= energy}\\
{\tt MCBranch=x}\\
is converted into\\
{\tt Pdf\_0\_MCBranch\_00=energy}\\
{\tt Pdf\_0\_MCBranch\_01=x}\\
When {\tt new} is called again for an object inside a {\tt Pdf}, such
as {\tt Axis}, that counter begins incrementing.  Then a command is
appended with {\tt Pdf\_0\_Axis\_0\_}, assuming this is both the first
{\tt Pdf} and the first {\tt Axis}.  {\tt Bin} is again a special case
with its own counting system, but this time the format is slightly
different, as\\
{\tt Bin=1}\\
becomes\\
{\tt Pdf\_0\_Axis\_0\_Bin00=1}\\
All of counters under a particular object are reset when {\tt new} is
called for that object, so if {\tt new Pdf} is called, the first call
of {\tt MCBranch=y} will give\\
{\tt Pdf\_1\_MCBranch\_00=y}

This pattern is repeated for every object with sub-objects.  Those
that interact directly with the MCMC, however, are kept track of
separately.  The MCMC directives are just copied, as they take the
same form in both the config and meta files.  The {\tt Parameter}
counter is never reset, calling {\tt new Parameter} anywhere in the
meta file increments it.

One word of caution is that the {\tt metaConfig.exe} program does very
little error checking.  It will return errors if it encounters
something it can't translate into a config file, such as creating a
{\tt Axis} without first creating a {\tt Pdf}.  It will also return an
error if it encounters a command it doesn't recognize - both in the
sense of commands that don't conform to the pattern key=value, and in
the sense of calling something like {\tt new Banana}, as it does not
recognize an {\tt Banana} class.  Anything else that fits the valid
patterns will be allowed.  It is thus essential to run a test run of
any config file through {\tt Malleus} to make sure setup
completes properly.


\section{Other Programs}
\label{sec:otherProgs}
The other three programs included, {\tt autoFit.exe}, {\tt
drawResults.exe} and {\tt getAutoCorr.exe}, are simple enough that the
built-in help is sufficient.  This can be accessed by running either
the the program with no arguments or with the argument {\tt --help}.

